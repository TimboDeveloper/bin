#!/bin/sh

source ./scripts/utils

if [[ $? -gt 0 ]]; then
    echo "exception: you need to be in the repository path" >&2
    return
fi

only_execute_without_source

if [[ $? -gt 0 ]]; then
    return
fi

gotoRoot

trigged_help=$(man $@)

if ! [[ -z $trigged_help ]]; then
    case $trigged_help in
        create|c)
            find_man create
            break
        ;;

        delete|del)
            find_man delete
            break
        ;;

        link|ln)
            find_man link
            break
        ;;

        removelink|rmlink|rmln)
            find_man removelink
            break
        ;;

        dependency|dep)
            find_man dependency
            break
        ;;

        add|a)
            while true; do
                case $1 in
                    dependency|dep)
                        find_man dependency_add
                        break
                    ;;
                    *)
                        shift
                    ;;
                esac
            done
            break
        ;;

        get|g)
            while true; do
                case $1 in
                    dependency|dep)
                        find_man dependency_get
                        break
                    ;;
                    *)
                        shift
                    ;;
                esac
            done
            break
        ;;

        init)
            while true; do
                case $1 in
                    dependency|dep)
                        find_man dependency_init
                        break
                    ;;
                    *)
                        shift
                    ;;
                esac
            done
            break
        ;;

        --verbose|-v)
            find_man verbose
            break
        ;;
        
        --force)
            find_man force
            break
        ;;

        --yes)
            find_man yes
            break
        ;;

        --quiet|-q)
            find_man quiet
            break
        ;;

        *)
            if [[ $trigged_help != $0 ]]; then
                if [[ $trigged_help != --* ]]; then
                    exception "command '$trigged_help' not found"
                    info
                else
                    exception "unrecognized option '$trigged_help'"
                    info
                fi
            fi

            find_man default
            break
        ;;
    esac

    exit 0
fi

options=$(getopt                                \
    -o hvq                                      \
    --long help,verbose,force,yes,quiet         \
    --name "exception"                          \
    --unquoted                                  \
    -- "$@"
)

if [[ $? -gt 0 ]]; then
    info
    find_man default
    exit $?
fi

eval set -- "$options"

temporary_options=()

for option in $options; do
    if [[ $option != '--' ]]; then
        temporary_options+=("$option")
    fi
done

set -- ${temporary_options[@]}

defined_options=(" ")

append_option() {
    local option=${1}

    defined_options+=" $option"
}

while true; do
    case $1 in
        --verbose|-v)
            append_option $1
            shift
            readonly BINARA_VERBOSE_MODE=true
        ;;
        
        --force)
            append_option $1
            shift
            readonly BINARA_FORCE_MODE=true
        ;;

        --yes)
            append_option $1
            shift
            readonly BINARA_YES_MODE=true
        ;;

        --quiet|-q)
            append_option $1
            shift
            readonly BINARA_QUIET_MODE=true
        ;;

        *)
            break
        ;;
    esac
done

readonly command=$1

if [[ -z $command ]]; then
    find_man default
    exit 128
fi

shift

readonly args=$@

show_help_if_empty_args

while true; do
    case $command in
        create|c)
            define_max_args 1
            package_name=$1

            if [[ -d "$PACKAGE_DIR/$package_name" ]]; then
                if ! [[ $BINARA_FORCE_MODE ]]; then
                    exception "the package '$package_name' already exists"
                    exit 1
                fi

                if ! request_accept; then
                    exit 0
                fi

                verbose "rm: $PACKAGE_DIR/$package_name"
                rm -rf "$PACKAGE_DIR/$package_name"
            fi
            
            create_dir "$PACKAGE_DIR/$package_name" -p 
            create_dir "$PACKAGE_DIR/$package_name/$HEADERS_DIR" -p
            create_file "$PACKAGE_DIR/$package_name/$C_MAIN_FILE.c"

            verbose ""

            rerun dep init $package_name

            info "package '$package_name' has been created"
            break
        ;;

        delete|del)
            define_max_args 1
            package_name=$1

            exist_package $package_name

            if ! request_accept; then
                exit 0
            fi

            verbose "rm: '$PACKAGE_DIR/$package_name'"
            rm -rf "$PACKAGE_DIR/$package_name"

            verbose ""

            info "package '$package_name' has been removed"
            break
        ;;

        link|ln)
            set_args 2

            target_package=${1}
            receiver_package=${2}

            exist_package $target_package
            exist_package $receiver_package

            if [[ -d "$PACKAGE_DIR/$receiver_package/$target_package" ]]; then
                exception "symbolic link already exists in '$receiver_package'"
                exit 1
            fi

            if ! [[ -d "$PACKAGE_DIR/$target_package/$HEADERS_DIR" ]]; then
                exception "$HEADERS_DIR folder not found from '$target_package'"
                exit 1
            fi

            verbose "link: '$PACKAGE_DIR/$target_package' to '$PACKAGE_DIR/$receiver_package'"
            ln -sr $PACKAGE_DIR/$target_package/$HEADERS_DIR $PACKAGE_DIR/$receiver_package/$target_package

            verbose ""

            info "symbolic link '$target_package' has been created in '$receiver_package'"

            break
        ;;

        removelink|rmlink|rmln)
            set_args 2

            target_package=${1}
            receiver_package=${2}

            exist_package $target_package
            exist_package $receiver_package
            
            if [[ -d "$PACKAGE_DIR/$receiver_package/$target_package" ]]; then
                remove_file "$PACKAGE_DIR/$receiver_package/$target_package" -f
            else
                exception "symbolic link '$target_package' not found in '$receiver_package'"
                exit 1
            fi

            verbose ""
            info "symbolic link '$target_package' has been removed from '$receiver_package'"

            break
        ;;

        dependency|dep)
            readonly subcommand=${1}

            case $subcommand in
                init)
                    subcommand_man="dependency_init"
                    set_args 2
                    shift

                    target_package=${1}
                    target_path="$PACKAGE_DIR/$target_package/$DEPENDENCY_FILE"
                    
                    create_dependency() {
                        create_file "$target_path"
                        echo "$DEPENDENCY_FILE_PREFIX" >> $target_path
                        
                        info "$DEPENDENCY_FILE has been initialized at '$target_package'"
                        exit 0
                    }

                    if ! [[ -f "$target_path" ]]; then
                        create_dependency
                    fi

                    info "The dependencies file already exists at '$target_path'"
                    if request_accept; then
                        verbose "rm: '$target_path'"
                        rm -f $target_path
                        
                        create_dependency
                    fi
                    break
                ;;

                add|a)
                    subcommand_man="dependency_add"
                    set_args 3
                    shift

                    target_dependency=${1}
                    target_path="$PACKAGE_DIR/$target_dependency"

                    receiver_package=${2}
                    receiver_path="$PACKAGE_DIR/$receiver_package"
    
                    exist_package $receiver_package

                    if ! [[ -f "$target_path" || -d "$receiver_path" ]]; then
                        exception "the provided dependency '$receiver_path' not found"
                        exit 1
                    fi

                    if [[ -f $target_path ]]; then
                        dependency_add $target_path $receiver_path

                        if [[ $? =~ 0 ]]; then
                            info "Dependency '$target_dependency' has been added to $receiver_package"
                        else
                            info "Nothing changed"
                        fi
                    fi

                    if [[ -d $target_path ]]; then
                        dependency_files_target=$(find $target_path -maxdepth 1 -not -name "$DEPENDENCY_FILE" -type f)
                        dependency_changed=()

                        for dependency_file_target in $dependency_files_target; do
                            dependency_add $dependency_file_target $receiver_path
                            dependency_changed+=$?
                        done

                        if [[ "$dependency_changed" =~ 0 ]]; then
                            info "Dependency '$target_dependency' has been added to $receiver_package"
                        else
                            info "Nothing changed"
                        fi
                    fi
                    break
                ;;

                get|g)                    
                    subcommand_man="dependency_get"
                    set_args 2
                    shift

                    target_package=${1}
                    target_path="$PACKAGE_DIR/$target_package/$DEPENDENCY_FILE"

                    paths=$(cat $target_path | grep -P "[-]" | sed 's/ - //g')

                    for path in $paths; do
                        if ! [ -f $path ]; then
                            exception "path '$path' not found"
                            exit 1
                        fi

                        echo $path
                    done
                    break
                ;;

                *)
                    exception "command '$subcommand' not found"
                    info
                    find_man dependency
                    break
                ;;
            esac
            break
        ;;

        *)
            if ! [[ -z $command ]]; then
                exception "command '$command' not found"
                info
            fi

            find_man default
            break
        ;;
    esac

    exit 127
done
