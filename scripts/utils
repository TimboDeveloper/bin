#!/bin/sh

PACKAGE_DIR="packages"
HEADERS_DIR="headers"
C_MAIN_FILE="main"
DEPENDENCY_FILE="dependencies.yml"
DEPENDENCY_FILE_PREFIX="dependencies:"

gotoRoot() {
    cd $(realpath $(dirname $(realpath "$0"))/../)
}

rerun() {
    local binara_args=$@

    $0 $defined_options $binara_args
}

isNumber() {
    local value=${1}
    local regex='^[+-]?[0-9]+([.][0-9]+)?$'

    if [[ $value =~ $regex ]]; then
        return 0
    else
        return 1
    fi
}

has_outrun() {
    local max_args=${1}
    local num_args=$(($# - 1))

    if ! isNumber $max_args; then
        exception "the provided value '$max_args' is not a number"
        exit 1
    fi

    if [ $max_args -ge $num_args ]; then
        return 1
    else
        return 0
    fi
}

has_outrun() {
    local max_args=${1}
    local num_args=$(($# - 1))

    if ! isNumber $max_args; then
        exception "the provided value '$max_args' is not a number"
        exit 1
    fi

    if [ $max_args -ge $num_args ]; then
        return 1
    else
        return 0
    fi
}

has_not_equal() {
    local min_args=${1}
    local num_args=$(($# - 1))

    if ! isNumber $min_args; then
        exception "the provided value '$min_args' is not a number"
        exit 1
    fi

    if [ $num_args -lt $min_args ]; then
        return 1
    else
        return 0
    fi
}

is_out_scope() {
    local variable=${1}

    if [[ -z $variable ]]; then
        exception "execution function is out of scope"
        exit 126
    fi
}

show_help_if_empty_args() {
    if [[ -z $args ]]; then
        is_out_scope $command

        find_man $command
        exit 128
    fi
}

create_dir() {
    local dir_path=${1}
    shift
    local mkdir_args=$@
    
    verbose "mkdir: '$dir_path'"
    mkdir $mkdir_args $dir_path
}

remove_file() {
    local dir_path=${1}
    shift
    local rm_args=$@
    
    verbose "rm: '$dir_path'"
    rm $rm_args $dir_path
}

create_file() {
    local file_path=${1}
    shift
    local touch_args=$@

    verbose "touch: '$file_path'"
    touch $touch_args $file_path
}

exist_package() {
    package_path=${1}

    if ! [[ -d "$PACKAGE_DIR/$package_path" ]]; then
        exception "package '$package_path' not found"
        exit 1
    fi
}

has_dependency() {
    local target=${1}
    local dependency_file=${2}
    local dependency_content=$(cat $dependency_file)

    if [[ "$dependency_content" =~ "$target" ]]; then
        return 0
    else
        return 1
    fi
}

dependency_add() {
    local target=${1}
    local receiver=${2}
    
    local dependency_file_path="$receiver/$DEPENDENCY_FILE"

    if [[ ! -f "$dependency_file_path" ]]; then
        create_file $dependency_file_path
    fi
    
    local dependency_content=$(cat $dependency_file_path)

    if has_dependency "$target" $dependency_file_path; then
        if ! [[ "$dependency_content" =~ "$DEPENDENCY_FILE_PREFIX" ]]; then
            exception "malformed dependency file at '$dependency_file_path'"
            exit 1
        fi

        verbose "nothing: dependency '$target' already exists at '$(basename $receiver)'"

        return 1
    else
        if ! [[ "$dependency_content" =~ "$DEPENDENCY_FILE_PREFIX" ]]; then
            echo "$DEPENDENCY_FILE_PREFIX" >> "$dependency_file_path"
        fi

        verbose "echo: '$target' to '$(basename $receiver)'"
        echo " - $target" >> $dependency_file_path
    fi
}

define_max_args() {
    local max_args=${1}

    is_out_scope $args
    is_out_scope $command

    if ! [[ -z $subcommand ]]; then
        local commandName=$subcommand
        local manCommand=$subcommand_man
    else
        local commandName=$command
        local manCommand=$command
    fi

    if has_outrun $max_args $args; then
        exception "the '$commandName' command expects at most $max_args arguments"
        info
        find_man $manCommand
        exit 128
    fi
}

define_min_args() {
    local min_args=${1}

    is_out_scope $args
    is_out_scope $command

    if ! [[ -z $subcommand ]]; then
        local commandName=$subcommand
        local manCommand=$subcommand_man
    else
        local commandName=$command
        local manCommand=$command
    fi

    if ! has_not_equal $min_args $args; then
        exception "the '$commandName' command expects at least $min_args arguments"
        info
        find_man $manCommand
        exit 128
    fi
}

define_args() {
    local min_args=${1}
    local max_args=${2}

    define_min_args $min_args
    define_max_args $max_args
}

set_args() {
    local args_amount=${1}
    
    define_args $args_amount $args_amount
}

request_accept() {
    ask() {    
        printf "Do you really want to do this? (y/N): "
    }

    if [[ -z $BINARA_YES_MODE ]]; then
        ask
        while true; do
            read input
            uppercase_input=${input^^}

            case $uppercase_input in
                YES|Y)
                    return 0
                    break
                ;;
                NO|N)
                    echo "Operation cancelled"
                    return 1
                    break
                ;;
                *)
                    if [[ $uppercase_input == '' ]]; then
                        echo "Operation cancelled"
                        return 1
                        break
                    fi
                    exception "wrong response. Answer with yes or no"
                    ask
                ;;
            esac
        done
    fi
}

man() {
    for ((i=0; i<=${#@}; i++)); do
        case ${@:i:1} in
            --help | -h)
                last_argument=$((i - 1))
                echo ${@:$last_argument:1}
                break
            ;;
        esac
    done
}

find_man() {
    local help_target=${1}
    local help_file="./scripts/man.md"

    if [ ! -f "$help_file" ]; then
        exception "help messages files is not avaliable"
        exit 1
    fi

    man_content=$(cat $help_file)

    if [[ $man_content =~ \[group-start\]:\ \<\>\ \($help_target\) ]]; then
        extracted_text=$(echo "$man_content)" | sed -n "/\[group-start\]: <> ($help_target)/,/\[group-end\]: <> ($help_target)/ { /(\[group-start\]|\[group-end\]): <> ($help_target)/!p }" | sed '1d;$d')
        echo "$extracted_text"
    else
        exception "cannot find '$help_target' help message"
    fi
}

verbose() {
    local message=$@

    if [[ $BINARA_VERBOSE_MODE ]]; then
        echo "$message"
    fi
}

info() {
    local message=$@

    if ! [[ $BINARA_QUIET_MODE ]]; then    
        echo "$message"
    fi
}

exception() {
    local message=$@
    local prefix='exception:'

    echo "$prefix $message" >&2
}

has_sourced() {
    if [ -n "$ZSH_VERSION" ]; then
        case $ZSH_EVAL_CONTEXT in 
        *:file*)
            echo true
            return
        ;;
        esac
    else
        case ${0##*/} in
        dash|-dash|bash|-bash|ksh|-ksh|sh|-sh) 
            echo true
            return
        ;; 
        esac
    fi
    echo false
    return
}

only_execute_with_source() {
    local is_sourced=$(has_sourced)

    if [[ $is_sourced != true ]]; then
        exception "this script only works with source command"
        return 1
    fi

    return 0
}

only_execute_without_source() {
    local is_sourced=$(has_sourced)

    if [[ $is_sourced != false ]]; then
        exception "this script only works without source command"
        return 1
    fi

    return 0
}
